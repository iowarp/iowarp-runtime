#!/usr/bin/env python3
"""
chi_refresh_repo - ChiMod Autogeneration Script

This script automatically generates libexec and methods header files
for ChiMods based on their chimaera_mod.yaml configuration files.

Usage:
    python chi_refresh_repo.py <chimod_repo_path>
"""

import os
import sys
import yaml
import argparse
from pathlib import Path
from typing import Dict, List, Any, Optional


class ChiModGenerator:
    """Generator for ChiMod autogenerated files."""
    
    def __init__(self, repo_path: str):
        self.repo_path = Path(repo_path).resolve()
        self.repo_yaml_path = self.repo_path / "chimaera_repo.yaml"
        
        if not self.repo_yaml_path.exists():
            raise FileNotFoundError(f"Repository YAML not found: {self.repo_yaml_path}")
    
    def load_repo_config(self) -> Dict[str, Any]:
        """Load the repository configuration."""
        with open(self.repo_yaml_path, 'r') as f:
            return yaml.safe_load(f)
    
    def load_chimod_config(self, chimod_name: str) -> Dict[str, Any]:
        """Load a specific ChiMod configuration."""
        chimod_yaml_path = self.repo_path / chimod_name / "chimaera_mod.yaml"
        if not chimod_yaml_path.exists():
            raise FileNotFoundError(f"ChiMod YAML not found: {chimod_yaml_path}")
        
        with open(chimod_yaml_path, 'r') as f:
            return yaml.safe_load(f)
    
    def get_methods(self, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract methods from configuration, filtering out those with value -1."""
        methods = []
        
        # Process all key-value pairs in the config
        for key, value in config.items():
            # Skip non-method keys
            if not key.startswith('k') or not isinstance(value, int):
                continue
            
            # Skip unimplemented methods (value -1)
            if value == -1:
                continue
            
            method_name = key[1:]  # Remove the 'k' prefix
            methods.append({
                'constant_name': key,
                'method_name': method_name,
                'method_id': value,
                'is_inherited': value < 10  # Inherited methods have IDs < 10
            })
        
        # Sort by method ID
        methods.sort(key=lambda m: m['method_id'])
        return methods
    
    def generate_methods_header(self, chimod_name: str, config: Dict[str, Any]) -> str:
        """Generate the methods header file."""
        methods = self.get_methods(config)
        namespace = config.get('namespace', 'chimaera')
        module_name = config.get('module_name', chimod_name)
        
        # Build the header content
        lines = [
            f"#ifndef {chimod_name.upper()}_AUTOGEN_METHODS_H_",
            f"#define {chimod_name.upper()}_AUTOGEN_METHODS_H_",
            "",
            "#include <chimaera/chimaera.h>",
            "",
            "/**",
            f" * Auto-generated method definitions for {module_name}",
            " */",
            "",
            f"namespace {namespace}::{chimod_name} {{",
            "",
            "namespace Method {",
        ]
        
        # Add inherited methods
        inherited_methods = [m for m in methods if m['is_inherited']]
        if inherited_methods:
            lines.append("// Inherited methods")
            for method in inherited_methods:
                lines.append(f"GLOBAL_CONST chi::u32 {method['constant_name']} = {method['method_id']};")
            lines.append("")
        
        # Add custom methods
        custom_methods = [m for m in methods if not m['is_inherited']]
        if custom_methods:
            lines.append(f"// {module_name}-specific methods")
            for method in custom_methods:
                lines.append(f"GLOBAL_CONST chi::u32 {method['constant_name']} = {method['method_id']};")
        
        lines.extend([
            "}  // namespace Method",
            "",
            f"}}  // namespace {namespace}::{chimod_name}",
            "",
            f"#endif  // {chimod_name.upper()}_AUTOGEN_METHODS_H_",
            ""
        ])
        
        return "\n".join(lines)
    
    def get_task_type_name(self, method_name: str, chimod_name: str) -> str:
        """Get the task type name for a method."""
        # Special cases for common inherited methods
        if method_name == "Create":
            return "CreateTask"
        elif method_name == "Destroy":
            return "DestroyTask"
        elif method_name.startswith("GetOrCreate"):
            # Template-based task
            return f"{chimod_name}::{method_name}Task<{chimod_name}::CreateParams>"
        else:
            # Regular task
            return f"{method_name}Task"
    
    def generate_lib_exec_header(self, chimod_name: str, config: Dict[str, Any]) -> str:
        """Generate the lib_exec header file."""
        methods = self.get_methods(config)
        namespace = config.get('namespace', 'chimaera')
        module_name = config.get('module_name', chimod_name)
        
        # Build the header content
        lines = [
            f"#ifndef {chimod_name.upper()}_AUTOGEN_LIB_EXEC_H_",
            f"#define {chimod_name.upper()}_AUTOGEN_LIB_EXEC_H_",
            "",
            "/**",
            f" * Auto-generated execution dispatcher for {module_name} ChiMod",
            " * Provides switch-case dispatch for all implemented methods",
            " */",
            "",
            "#include <chimaera/chimaera.h>",
            f'#include "{chimod_name}_methods.h"',
            f'#include "../{chimod_name}_runtime.h"',
            "",
            f"namespace {namespace}::{chimod_name} {{",
            "",
            "/**",
            " * Execute a method on the runtime",
            " */",
            "inline void Run(Runtime* runtime, chi::u32 method, hipc::FullPtr<chi::Task> task, chi::RunContext& rctx) {",
            "  switch (method) {"
        ]
        
        # Add switch cases for each method
        for method in methods:
            method_name = method['method_name']
            constant_name = method['constant_name']
            task_type = self.get_task_type_name(method_name, chimod_name)
            
            lines.extend([
                f"    case Method::{constant_name}: {{",
                f"      runtime->{method_name}(task.Cast<{task_type}>(), rctx);",
                "      break;",
                "    }"
            ])
        
        lines.extend([
            "    default: {",
            "      // Unknown method - do nothing",
            "      break;",
            "    }",
            "  }",
            "}",
            "",
            "/**",
            " * Save input data for a task (serialize task inputs)",
            " */",
            "inline void SaveIn(Runtime* runtime, chi::u32 method, chi::TaskSaveInArchive& archive, hipc::FullPtr<chi::Task> task_ptr) {",
            "  switch (method) {"
        ])
        
        # Add SaveIn switch cases
        for method in methods:
            method_name = method['method_name']
            constant_name = method['constant_name']
            task_type = self.get_task_type_name(method_name, chimod_name)
            
            lines.extend([
                f"    case Method::{constant_name}: {{",
                f"      auto typed_task = task_ptr.Cast<{task_type}>();",
                f"      typed_task->SerializeIn(archive);",
                "      break;",
                "    }"
            ])
        
        lines.extend([
            "    default: {",
            "      // Unknown method - do nothing",
            "      break;",
            "    }",
            "  }",
            "}",
            "",
            "/**",
            " * Load input data for a task (deserialize task inputs)",
            " */",
            "inline void LoadIn(Runtime* runtime, chi::u32 method, chi::TaskLoadInArchive& archive, hipc::FullPtr<chi::Task> task_ptr) {",
            "  switch (method) {"
        ])
        
        # Add LoadIn switch cases
        for method in methods:
            method_name = method['method_name']
            constant_name = method['constant_name']
            task_type = self.get_task_type_name(method_name, chimod_name)
            
            lines.extend([
                f"    case Method::{constant_name}: {{",
                f"      auto typed_task = task_ptr.Cast<{task_type}>();",
                f"      typed_task->SerializeIn(archive);",
                "      break;",
                "    }"
            ])
        
        lines.extend([
            "    default: {",
            "      // Unknown method - do nothing",
            "      break;",
            "    }",
            "  }",
            "}",
            "",
            "/**",
            " * Save output data for a task (serialize task outputs)",
            " */",
            "inline void SaveOut(Runtime* runtime, chi::u32 method, chi::TaskSaveOutArchive& archive, hipc::FullPtr<chi::Task> task_ptr) {",
            "  switch (method) {"
        ])
        
        # Add SaveOut switch cases  
        for method in methods:
            method_name = method['method_name']
            constant_name = method['constant_name']
            task_type = self.get_task_type_name(method_name, chimod_name)
            
            lines.extend([
                f"    case Method::{constant_name}: {{",
                f"      auto typed_task = task_ptr.Cast<{task_type}>();",
                f"      typed_task->SerializeOut(archive);",
                "      break;",
                "    }"
            ])
        
        lines.extend([
            "    default: {",
            "      // Unknown method - do nothing",
            "      break;",
            "    }",
            "  }",
            "}",
            "",
            "/**",
            " * Load output data for a task (deserialize task outputs)",
            " */",
            "inline void LoadOut(Runtime* runtime, chi::u32 method, chi::TaskLoadOutArchive& archive, hipc::FullPtr<chi::Task> task_ptr) {",
            "  switch (method) {"
        ])
        
        # Add LoadOut switch cases
        for method in methods:
            method_name = method['method_name']
            constant_name = method['constant_name']
            task_type = self.get_task_type_name(method_name, chimod_name)
            
            lines.extend([
                f"    case Method::{constant_name}: {{",
                f"      auto typed_task = task_ptr.Cast<{task_type}>();",
                f"      typed_task->SerializeOut(archive);",
                "      break;",
                "    }"
            ])
        
        lines.extend([
            "    default: {",
            "      // Unknown method - do nothing",
            "      break;",
            "    }",
            "  }",
            "}",
            "",
            "/**",
            " * Monitor a method on the runtime",
            " */",
            "inline void Monitor(Runtime* runtime, chi::MonitorModeId mode, chi::u32 method,",
            "                   hipc::FullPtr<chi::Task> task_ptr, chi::RunContext& rctx) {",
            "  switch (method) {"
        ])
        
        # Add monitor switch cases
        for method in methods:
            method_name = method['method_name']
            constant_name = method['constant_name']
            task_type = self.get_task_type_name(method_name, chimod_name)
            
            lines.extend([
                f"    case Method::{constant_name}: {{",
                f"      runtime->Monitor{method_name}(mode, task_ptr.Cast<{task_type}>(), rctx);",
                "      break;",
                "    }"
            ])
        
        lines.extend([
            "    default: {",
            "      // Unknown method - do nothing",
            "      break;",
            "    }",
            "  }",
            "}",
            "",
            "/**",
            " * Delete a task from shared memory",
            " * Uses IPC manager to properly deallocate the task",
            " */",
            "inline void Del(Runtime* runtime, chi::u32 method, hipc::FullPtr<chi::Task> task_ptr) {",
            "  // Use IPC manager to deallocate task from shared memory",
            "  auto* ipc_manager = CHI_IPC;",
            "  ",
            "  switch (method) {"
        ])
        
        # Add delete switch cases
        for method in methods:
            method_name = method['method_name']
            constant_name = method['constant_name']
            task_type = self.get_task_type_name(method_name, chimod_name)
            
            lines.extend([
                f"    case Method::{constant_name}: {{",
                f"      ipc_manager->DelTask(task_ptr.Cast<{task_type}>());",
                "      break;",
                "    }"
            ])
        
        lines.extend([
            "    default: {",
            "      // For unknown methods, still try to delete from main segment",
            "      ipc_manager->DelTask(task_ptr);",
            "      break;",
            "    }",
            "  }",
            "  ",
            "  (void)runtime; // Runtime not needed for IPC-managed deletion",
            "}",
            "",
            "/**",
            " * Create a new copy of a task (deep copy for distributed execution)",
            " */",
            "inline void NewCopy(Runtime* runtime, chi::u32 method,",
            "                    const hipc::FullPtr<chi::Task>& orig_task,",
            "                    hipc::FullPtr<chi::Task>& dup_task, bool deep) {",
            "  auto* ipc_manager = CHI_IPC;",
            "  if (!ipc_manager) {",
            "    return;",
            "  }",
            "  ",
            "  switch (method) {"
        ])
        
        # Add NewCopy switch cases
        for method in methods:
            method_name = method['method_name']
            constant_name = method['constant_name']
            task_type = self.get_task_type_name(method_name, chimod_name)
            
            lines.extend([
                f"    case Method::{constant_name}: {{",
                f"      // Allocate new task using SHM default constructor",
                f"      auto typed_task = ipc_manager->NewTask<{task_type}>();",
                f"      if (!typed_task.IsNull()) {{",
                f"        // Use HSHM strong copy method for actual copying",
                f"        typed_task->shm_strong_copy_main(*orig_task.Cast<{task_type}>());",
                f"        // Cast to base Task type for return",
                f"        dup_task = typed_task.template Cast<chi::Task>();",
                f"      }}",
                "      break;",
                "    }"
            ])
        
        lines.extend([
            "    default: {",
            "      // For unknown methods, create base Task copy",
            "      auto typed_task = ipc_manager->NewTask<chi::Task>();",
            "      if (!typed_task.IsNull()) {",
            "        typed_task->shm_strong_copy_main(*orig_task);",
            "        dup_task = typed_task;  // Already chi::Task type",
            "      }",
            "      break;",
            "    }",
            "  }",
            "  ",
            "  (void)runtime; // Runtime not needed for IPC-managed allocation",
            "  (void)deep;    // Deep copy parameter reserved for future use",
            "}",
            "",
            f"}} // namespace {namespace}::{chimod_name}",
            "",
            f"#endif // {chimod_name.upper()}_AUTOGEN_LIB_EXEC_H_",
            ""
        ])
        
        return "\n".join(lines)
    
    def generate_chimod_files(self, chimod_name: str):
        """Generate autogen files for a single ChiMod."""
        print(f"Generating files for ChiMod: {chimod_name}")
        
        # Load ChiMod configuration
        try:
            config = self.load_chimod_config(chimod_name)
        except FileNotFoundError as e:
            print(f"Warning: {e}")
            return
        
        # Create autogen directory
        autogen_dir = self.repo_path / chimod_name / "include" / chimod_name / "autogen"
        autogen_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate methods header
        methods_content = self.generate_methods_header(chimod_name, config)
        methods_file = autogen_dir / f"{chimod_name}_methods.h"
        with open(methods_file, 'w') as f:
            f.write(methods_content)
        print(f"  Generated: {methods_file}")
        
        # Generate lib_exec header
        lib_exec_content = self.generate_lib_exec_header(chimod_name, config)
        lib_exec_file = autogen_dir / f"{chimod_name}_lib_exec.h"
        with open(lib_exec_file, 'w') as f:
            f.write(lib_exec_content)
        print(f"  Generated: {lib_exec_file}")
    
    def refresh_repo(self):
        """Refresh all ChiMods in the repository."""
        repo_config = self.load_repo_config()
        modules = repo_config.get('modules', [])
        
        print(f"Refreshing ChiMod repository: {self.repo_path}")
        print(f"Found {len(modules)} modules: {', '.join(modules)}")
        print()
        
        for chimod_name in modules:
            self.generate_chimod_files(chimod_name)
            print()
        
        print("Repository refresh complete!")


def main():
    parser = argparse.ArgumentParser(
        description='Autogenerate ChiMod libexec and methods files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python chi_refresh_repo.py /path/to/chimods
  python chi_refresh_repo.py .
        """
    )
    
    parser.add_argument(
        'repo_path',
        help='Path to the ChiMod repository containing chimaera_repo.yaml'
    )
    
    args = parser.parse_args()
    
    try:
        generator = ChiModGenerator(args.repo_path)
        generator.refresh_repo()
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()